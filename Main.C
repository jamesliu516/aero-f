#include <IoData.h>
#include <GeoSource.h>
#include <Domain.h>
#include <Modal.h>

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

#ifdef DO_MODAL
#include <ArpackUtil.h>
#endif

#include <fenv.h>
#include <Timer.h>
#include "LevelSet/IntersectionFactory.h"

#include "OneDimensionalSolver.h"

extern void startNavierStokesSolver(IoData &, GeoSource &, Domain &);
extern void startModalSolver(Communicator *, IoData &, Domain &);
extern void startSparseGridGeneration(IoData &, Domain &);
int interruptCode = 0;



int  atexit(void (*function)(void)) { exit(-1);}

//------------------------------------------------------------------------------

extern "C" void processSignal(int num)
{

  if (num == SIGUSR1) {
    fprintf(stderr, "*** Warning: interruption generated by the user\n");
    interruptCode = 1;
  }

}

//------------------------------------------------------------------------------

#ifdef CREATE_DSO
extern "C" int entrypoint(int argc, char **argv)
#else
int main(int argc, char **argv)
#endif
{
#ifndef CREATE_DSO
  initCommunication(argc, argv);
#endif

  //sleep(20);

  signal(SIGUSR1, processSignal);

  feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW );

  Domain domain;
  Timer *timer = domain.getTimer();
//  fprintf(stderr,"TIMER::START TIME: %lf\n",timer->getTime());

  Communicator *com = domain.getCommunicator();
  IntersectionFactory::setCommunicator(com);
  // iodata obtains all the problem parameters from the cmd line and input file(s)
  IoData ioData(com);
  ioData.readCmdLine(argc, argv);
  ioData.readCmdFile();

  OneDimensional one(ioData,&domain);
  one.spatialSetup();
  one.temporalSetup();
  one.stateInitialization(ioData.oneDimensionalInfo);
  one.totalTimeIntegration();

/*  if (ioData.problem.alltype==ProblemData::_SPARSEGRIDGEN_){
    startSparseGridGeneration(ioData,domain);
  }else{
    // obtain problem geometry
    GeoSource geoSource(ioData);
    geoSource.readConnectivityInfo(com);
    domain.getGeometry(geoSource, ioData);
    domain.numberEdges();
    domain.setNodeType(ioData);
    domain.setFaceToElementConnectivity();
    domain.makeRotationOwnership(ioData);
    domain.setInletNodes(ioData);

    domain.printElementStatistics();

    // choose between linearized and nonlinear fluid problems
    if (ioData.problem.type[ProblemData::LINEARIZED])
      startModalSolver(com, ioData, domain);
    else
      startNavierStokesSolver(ioData, geoSource, domain);
  }
*/
#ifndef CREATE_DSO
  closeCommunication();
#endif

  return 0;

}

//------------------------------------------------------------------------------
